# 목차
- [목차](#목차)
- [수동테스트 vs 자동화된 테스트](#수동테스트-vs-자동화된-테스트)
- [단위 테스트 Unit test](#단위-테스트-unit-test)
  - [JUnit5](#junit5)
  - [AssertJ](#assertj)
- [테스트 케이스 세분화하기](#테스트-케이스-세분화하기)
  - [해피 케이스와 예외 케이스](#해피-케이스와-예외-케이스)
- [테스트하기 어려운 영역을 분리하기](#테스트하기-어려운-영역을-분리하기)

---

# 수동테스트 vs 자동화된 테스트

# 단위 테스트 Unit test

작은 코드(클래스 or 메서드) 단위로 독립적으로 검증하는 테스트  

검증 속도가 빠르고, 안정적이다.  
- 검증 속도가 빠른 이유 : 작은 코드 단위로 테스트하기 때문
- 안정적인 이유: 외부 요인의 영향을 받지 않기 때문

## [JUnit5](https://junit.org/junit5/docs/current/user-guide/)

단위 테스트를 위한 테스트 `프레임워크`

## AssertJ

- 테스트 코드 작성을 원할하게 돕는 테스트 `라이브러리`
- 풍부한 API, 메서드 체이닝 지원

# 테스트 케이스 세분화하기

테스트를 진행할 때 스스로에게 질문해야할 것이 있다.  
-> `암묵적이거나 아직 드러나지 않은 요구사항이 있는가?`

## 해피 케이스와 예외 케이스

해피 케이스 : 요구 사항을 그대로 만족하는 케이스  
예외 케이스 : 숨겨져 있는 요구 사항이 존재하는 경우  

경계값 테스트를 잘해야 한다.  
-> 범위(이상 이하, 초과, 미만), 구간, 날짜 등

# 테스트하기 어려운 영역을 분리하기

테스트하기 어려운 코드는 외부의 영향을 받는 코드다    
- 관측할 때마다 다른 값에 의존하는 코드
  - 현재 날짜/시간, 랜덤 값, 전역 변수/함수, 사용자 입력 등
- 외부 세계에 영향을 주는 코드
  - 표준 출력, 메시지 발송, 데이터베이스에 기록하기 등

따라서, 코드는 다음과 같이 작성하는 것이 좋다.  
- 같은 입력에는 항상 같은 결과
- 외부 세상과 단절된 형태
- 테스트하기 쉬운 코드

테스트를 위해 설계를 변경하는 것은 자연스러운 일이다.




