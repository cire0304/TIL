# 목차
---


# ArrayList

내부적으로 특정한 크기의 배열을 가지고 있음

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
{
    private static final int DEFAULT_CAPACITY = 10; // 기본 사이즈는 10
    transient Object[] elementData; // 데이터가 저장되는 배열
    private int size; // 배열의 사이즈

    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
}
```

## 배열이 꽉 찼을 때 값을 추가하면 어떻게 될까?

배열은 크기는 고정되어 있습니다.  
따라서 새로운 배열을 만들고, 그 배열에 기존의 배열의 값을 복사합니다.

```java
    public boolean add(E e) {
        modCount++;
        add(e, elementData, size); // 값 추가
        return true;
    }
```

```java
private void add(E e, Object[] elementData, int s) {
        // 기존의 배열이 크기가 차있다면
        if (s == elementData.length)
            elementData = grow(); // 배열의 크기 증가
        elementData[s] = e;
        size = s + 1;
    }
```

```java
    private Object[] grow() {
        return grow(size + 1);
    }
```

```java
    private Object[] grow(int minCapacity) {
        int oldCapacity = elementData.length;
        if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            // 새로운 배열의 크기 = 기존의 배열의 크기 + Math.max(기존의 배열의 크기 / 2, 1)
            int newCapacity = ArraysSupport.newLength(oldCapacity, // 기존의 배열의 크기
                    minCapacity - oldCapacity, // 크기 1
                    oldCapacity >> 1); // 기존 배열의 크기의 절반

            // 새로운 배열에 기존의 배열을 복사
            return elementData = Arrays.copyOf(elementData, newCapacity);
        } else {
            return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];
        }
    }
```

결과적으로 새로운 배열의 크기는 (3/2) * 기존의 배열의 크기가 됨을 알 수 있습니다. (새로운 배열의 크기가 오버플로우가 발생하지 않을 경우)
