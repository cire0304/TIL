
# 목차
- [목차](#목차)
- [AtomicInteger](#atomicinteger)
- [ThreadLocal](#threadlocal)
- [lock-contention](#lock-contention)
- [Permanet Generation](#permanet-generation)



# AtomicInteger

자바의 동시성 문제를 해결하는 방법 중 하나이다.

`하지만, AtomicInteger을 사용하다고 해서 동시성 문제가 해결되는 것은 아니다.`

아래의 코드로 실험을 해보자.
단순히 AtomicInteger 타입의 sharedInt 정적 변수를 count 만큼 더하는 로직이다.

```java
public class MyThread extends Thread {
    public static AtomicInteger sharedInt = new AtomicInteger();
    private int count = 100_000_000;

    public void setSharedInt(int sharedInt) {
        this.sharedInt.set(sharedInt);
    }

    public int getSharedInt() {
        return sharedInt.get();
    }

    @Override
    public void run() {
        // sharedInt 에 1씩 count 만큼 더함
        for (int i = 0; i < count ; i++) {
            int tmp = getSharedInt();
            setSharedInt(tmp + 1);
        }
    }
}
```
```java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        MyThread myThread1 = new MyThread();
        MyThread myThread2 = new MyThread();
        MyThread myThread3 = new MyThread();
        MyThread myThread4 = new MyThread();
        MyThread myThread5 = new MyThread();

        myThread1.start();
        myThread2.start();
        myThread3.start();
        myThread4.start();
        myThread5.start();

        myThread1.join();
        myThread2.join();
        myThread3.join();
        myThread4.join();
        myThread5.join();

        System.out.println(MyThread.sharedInt); 
        // 기대 값 : 100000000 * 5
        // 결과 값 : 83767658
    }
}
```

위의 결과를 보면 전혀 동시성 이슈가 해결되지 않았음을 알 수 있다.
그 이유는 AtomicInteger 의 get() 및 set() 메서드 구현을 보면 알 수 있다. 동시성을 제어하기 위한 로직은 아무것도 없이 단순히 값을 얻고, 할당하는 로직만이 있다. (volatile 예약어를 사용함으로써 가시성은 보장된다.)

```java
public class AtomicInteger extends Number implements java.io.Serializable {

    private volatile int value;

    public final int get() {
            return value;
        }

    public final void set(int newValue) {
        value = newValue;
    }
    // 생략
}
```

AtomicInteger은 CAS(compare-and-swap)라는 알고리즘을 사용하여 동시성을 보장한다. (정확히는 우리가 그렇게 사용해야하는 것 같다.)

```java
public class MyThread extends Thread {
    public static AtomicInteger sharedInt = new AtomicInteger();
    private int count = 100_000_000;

    @Override
    public void run() {
        for (int i = 0; i < count ; i++) {
            while (true) {
                int tmp = sharedInt.get();

                // 동시성을 보장하기 위한 메서드
                if (sharedInt.compareAndSet(tmp, tmp + 1)) {
                    break;
                }
            }
        }
    }
}
```

위의 코드는 sharedInt 변수에 대한 동시성을 보장한다.  

> 결론적으로 AtomicInteger 클래스를 사용한다고 해서 동시성이 보장되는 것이 아니라, AtomicInteger 클래스에서 제공하는 메서드를 적절히 사용하여 동시성이 보장되는 코드를 작성해야 하는 것이다.


> compareAndSet 메서드는 네이티브 코드로 작성되어 있다.

```java
 public final boolean compareAndSet(int expectedValue, int newValue) {
        return U.compareAndSetInt(this, VALUE, expectedValue, newValue);
    }
```

```java
@IntrinsicCandidate
    public final native boolean compareAndSetInt(Object o, long offset,
                                                 int expected,
                                                 int x);
```

# [ThreadLocal](https://madplay.github.io/post/java-threadlocal)


# lock-contention

# Permanet Generation
